#!/usr/bin/env python3

# Python core libraries
import sys
import os
import logging
from functools import partial

# PyQT5 files
from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QMainWindow, QApplication, QLabel
from PyQt5.QtCore import QThread, Qt
from PyQt5.QtGui import QIcon

# Window file generated by QT Designer
from gui.window_ui import Ui_MainWindow
from gui.notification import Notification

from user import User
from config import assets
from trayIcon import TrayIcon

if __debug__:
    from gui.logger_ui import LoggerDialog


class MainWindow(QMainWindow, Ui_MainWindow):
    closeWindow = False

    def __init__(self, app):
        super(MainWindow, self).__init__()
        self.app = app
        self.setupUi(self)

        icon = QIcon(assets['nautiljon_icon'])
        self.systemTrayIcon = TrayIcon(self, icon);
        self.setWindowIcon(icon)

        self.workerThread = QThread()
        self.user = User()
        self.user.moveToThread(self.workerThread)

    def cleanUp(self):
        Notification.cleanUp()

        self.user.cleanUp()
        self.workerThread.quit()
        self.workerThread.wait()

        # Hide the system tray icon or the user has to pass his mouse over
        # the icon so it disappear
        self.systemTrayIcon.hide()

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Return:
            self.onConnect(True)

    def closeEvent(self, event):
        # Don't close window if user exit window
        # Only quit if the "quit" option has been clicked in the system tray icon
        if not self.closeWindow:
            event.ignore()
            self.hide()
        # Close window and quit application
        else:
            self.close()
            self.cleanUp()
            self.app.quit()

    def displayLoginForm(self, display, showError = False):
        if display:
            self.loginForm.setVisible(False)
            self.connectError.setVisible(False)
            self.connectSuccess.setVisible(True)
        else:
            self.loginForm.setVisible(True)
            self.connectSuccess.setVisible(False)
            self.connectError.setVisible(showError)

    def displayNotification(self, notification):
        logging.debug('Window received notification')
        Notification.create(notification['title'], notification['message'], notification['pixmap'], notification['url'], notification.get('onClick'))

    def onConnect(self, checked):
        if self.workerThread.isRunning():
            return

        logging.debug('Connect button clicked')
        username = self.usernameInput.text()
        password = self.passwordInput.text()

        def finishedConnect(success):
            self.workerThread.exit()
            self.displayLoginForm(success, True)

        self.workerThread.quit()
        self.user.finished.connect(finishedConnect)
        self.workerThread.started.connect(partial(self.user.connect, username, password))
        self.workerThread.start()

def main():
    app = QApplication(sys.argv)
    # Set this option or the app will close
    # if a notification is closed when the window is hidden
    app.setQuitOnLastWindowClosed(False)

    main_window = MainWindow(app)

    if __debug__:
        logger_window = LoggerDialog(main_window)
        logger_window.move(0, 0)
        logger_window.setGeometry(0, 0, 1000, 300)
        logger_window.show()

    main_window.user.init(main_window.displayNotification)
    main_window.displayLoginForm(main_window.user.connected)
    main_window.show()

    ret = app.exec_()
    sys.exit(ret)

if __name__ == "__main__":
    main()
